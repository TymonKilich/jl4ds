<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tabular File IO · Julia for Data Science</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Julia for Data Science</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Julia for Data Science</a></li><li><a class="toctext" href="setup.html">Setup</a></li><li class="current"><a class="toctext" href="fileio.html">Tabular File IO</a><ul class="internal"><li><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#The-load-and-save-function-1">The <code>load</code> and <code>save</code> function</a></li><li><a class="toctext" href="#CSV-Files-1">CSV Files</a></li><li><a class="toctext" href="#Feather-Files-1">Feather Files</a></li><li><a class="toctext" href="#Excel-Files-1">Excel Files</a></li><li><a class="toctext" href="#Stata,-SPSS,-and-SAS-Files-1">Stata, SPSS, and SAS Files</a></li><li><a class="toctext" href="#Parquet-Files-1">Parquet Files</a></li><li><a class="toctext" href="#Alternative-Packages-1">Alternative Packages</a></li></ul></li><li><a class="toctext" href="iterabletables.html">Advanced - Iterable Tables</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="fileio.html">Tabular File IO</a></li></ul><a class="edit-page" href="https://github.com/davidanthoff/jl4ds/blob/master/docs/src/fileio.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tabular File IO</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tabular-File-IO-1" href="#Tabular-File-IO-1">Tabular File IO</a></h1><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This chapter is preliminary, and some of the things described in the text have not yet been implemented, i.e. some of the things described here will not currently work.</p></div></div><p>This chapter will teach you how to read and write data from files. We will limit the discussion to tabular data, i.e. data that has the structure of a table.</p><h2><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h2><h3><a class="nav-anchor" id="Loading-Data-1" href="#Loading-Data-1">Loading Data</a></h3><p>The main function for reading tabular data from disc is the <code>load</code> function from the <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> package. You always pass a filename as the first argument to the <code>load</code> function. For some file formats you can also pass additional arguments that control the details of how the data is loaded. You will learn about those additional arguments later in the chapter.</p><p>It is often convenient to materialize the data from a tabular file into a data structure like a <code>DataFrame</code>. You can do that easily by passing the return value from the <code>load</code> function to the <code>DataFrame</code> constructor, like this:</p><pre><code class="language-julia">using Dataverse

df = DataFrame(load(&quot;mydata.csv&quot;))</code></pre><p>You can also use the pipe syntax to achieve the same result:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.csv&quot;) |&gt; DataFrame</code></pre><p>The pipe syntax is particularly useful when you want to apply some data transformation to the data that you are loading. For example, you can filter the data before you materialize it into a <code>DataFrame</code> like this:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.csv&quot;) |&gt; @filter(_.age&gt;20) |&gt; DataFrame</code></pre><p>The <code>load</code> function can load many different tabular file formats. The following code loads an Excel file:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.xlsx&quot;, &quot;Sheet1&quot;) |&gt; DataFrame</code></pre><p>Note how we have to pass the name of the sheet to read as a second argument to the <code>load</code> function for Excel files.</p><p>A full list of supported file formats is provided later in this chapter.</p><p>You can also use the <code>load</code> function to acquire data from a remote server by passing a URI as the filename. The following code loads a CSV file from a remote server:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;https://raw.githubusercontent.com/davidanthoff/CSVFiles.jl/master/test/data.csv&quot;) |&gt; DataFrame</code></pre><h3><a class="nav-anchor" id="Saving-Data-1" href="#Saving-Data-1">Saving Data</a></h3><p>The <code>save</code> function from the <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> package is the main function to save tabular data to disc. The first argument to the <code>save</code> function is the filename you want to use for the file. The file extension of that filename will determine in what format the data will be written to disc. The second argument is the table you want to write to disc. Here is a simple example that writes some data to a CSV file:</p><pre><code class="language-julia">using Dataverse

df = DataFrame(Name=[&quot;Jim&quot;, &quot;Sally&quot;, &quot;John&quot;], Age=[23., 56., 34.])

save(&quot;mydata.csv&quot;, df)</code></pre><p>You can also use the pipe syntax with the <code>save</code> function:</p><pre><code class="language-julia">using Dataverse

df = DataFrame(Name=[&quot;Jim&quot;, &quot;Sally&quot;, &quot;John&quot;], Age=[23., 56., 34.])

df |&gt; save(&quot;mydata.csv&quot;)</code></pre><p>The <code>save</code> function works with any tabular data structure, not just <code>DataFrame</code>s and it supports many different file formats. The following code shows how you can load data from a CSV file, filter it and then write it out directly as a Feather file, without ever materializing it into a <code>DataFrame</code>:</p><pre><code class="language-julia">using Dataverse

load(&quot;mydata.csv&quot;) |&gt; @filter(_.age&gt;23) |&gt; save(&quot;mydata.feather&quot;)</code></pre><p>For some file formats you can pass additional configuration arguments to the <code>save</code> function that control in detail how the file is written to disc. The following example writes a table to disc as a CSV file, but uses a non-standard delimeter character and also does not write a header to the file:</p><pre><code class="language-julia">using Dataverse

df = DataFrame(Name=[&quot;Jim&quot;, &quot;Sally&quot;, &quot;John&quot;], Age=[23., 56., 34.])

df |&gt; save(&quot;mydata.csv&quot;, delim=&#39;;&#39;, header=false)</code></pre><h2><a class="nav-anchor" id="The-load-and-save-function-1" href="#The-load-and-save-function-1">The <code>load</code> and <code>save</code> function</a></h2><p>[TODO]</p><h2><a class="nav-anchor" id="CSV-Files-1" href="#CSV-Files-1">CSV Files</a></h2><p>[TODO add general description of CSV files]</p><h3><a class="nav-anchor" id="Loading-CSV-Files-1" href="#Loading-CSV-Files-1">Loading CSV Files</a></h3><p>If you pass a filename with the extension <code>*.csv</code> to the <code>load</code> function, <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> will use the <a href="https://github.com/davidanthoff/CSVFiles.jl">CSVFiles.jl</a> package to load that file. The package supports filenames that point to a file on your local computer and URLs that point to a file on remote server:</p><pre><code class="language-julia">using Dataverse

# Load a local file
df = load(&quot;mycsv.csv&quot;) |&gt; DataFrame

# Load a remote file
url = &quot;https://raw.githubusercontent.com/davidanthoff/CSVFiles.jl/master/test/data.csv&quot;
df = load(url) |&gt; DataFrame</code></pre><h4><a class="nav-anchor" id="Delimter-character-1" href="#Delimter-character-1">Delimter character</a></h4><p>By default, CSV files use a comma <code>,</code> to separate content in different columns. While that is the most common case, CSV files also sometimes use a different character to separate content in different columns. For example, you might want to read a file that uses a semicolon <code>;</code> to separate columns, like the following example:</p><pre><code class="language-none">Name;Age
John;34
Sally;52</code></pre><p>You can tell <code>load</code> to use a different character as the delimiter between columns by passing a <code>Char</code> value as the second argument to the <code>load</code> function:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mycsvfile_with_semicolon.csv&quot;, &#39;;&#39;) |&gt; DataFrame</code></pre><p>You can tell <code>load</code> to use any character as the column delimiter signal. Another common case besides the semicolon is a tab character (written as <code>&#39;\t&#39;</code> in julia).</p><h4><a class="nav-anchor" id="Column-Names-1" href="#Column-Names-1">Column Names</a></h4><p>In most CSV files the first line contains the names of the columns, and subsequent lines the actual data itself. If you call <code>load</code> with no special arguments, it will assume that the first line in the CSV file holds column names. An example of such a CSV file might look like this:</p><pre><code class="language-none">Name,Age,Children
&quot;John&quot;,23.,1
&quot;Sally&quot;,54.,3</code></pre><p>But sometimes CSV files don&#39;t have a special header row with the column names, and instead start with the actual data in the first row, like in this file:</p><pre><code class="language-none">&quot;John&quot;,23.,1
&quot;Sally&quot;,54.,3</code></pre><p>You can indicate this situation by calling the <code>load</code> function with the keyword argument <code>header_exists=false</code>:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;myfile.csv&quot;, header_exists=false) |&gt; DataFrame</code></pre><p>The <code>header_exists=false</code> keyword argument will cause two things: the first row of the file will now be read as data, i.e. the resulting table will have a first row with data from the first line in the file. Second, the columns will be named by numbers, i.e. the name of the first column will be <code>1</code>, the name of the second column <code>2</code> and so on, unless you specify custom column names with the <code>colnames</code> keyword argument.</p><p>The <code>colnames</code> keyword argument of the <code>load</code> function allows you to specify your own column names. You can use that option to either specify the names of all columns as an array of <code>String</code>s, or you can change the name of only a few columns by passing a <code>Dict</code>.</p><p>When you pass an array of <code>String</code>s, you indicate that you want the names in the array to be used as the column names in the resulting table. The following code loads a CSV file and specifies custom column names:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.csv&quot;, colnames=[&quot;name&quot;, &quot;age&quot;, &quot;children&quot;]) |&gt; DataFrame</code></pre><p>When you use the <code>colnames</code> argument with <code>header_exists=true</code> (or don&#39;t specify that keyword argument), the names in <code>colnames</code> will replace the names that are loaded from the file.</p><p>Sometimes you load some data from a CSV file that has a column header and you want to replace the names of just a few columns. While you could pass an array of <code>String</code>s to the <code>colnames</code> argument, it would cumbersome: you would have to specify the names of all columns, even the ones that you don&#39;t want to rename. In this situation you can pass a <code>Dict</code> to the <code>colnames</code> argument instead. Each element in the <code>Dict</code> is one renaming rule that <code>load</code> should apply to the columns it loads from the file. The key for each element specifies which column should be renamed, and the value the new name. The key can be specified either as a <code>String</code>, in which case it refers to the column name that is present in the file, or as an <code>Int</code>, in which case it refers to the position of the column that should be renamed. The values in the <code>Dict</code> always have to be <code>String</code>s, i.e. the new names. Note that you cannot pass a <code>Dict</code> to <code>colnames</code> when you call <code>load</code> with <code>header_exists=false</code>. The following code example will load a CSV file, and rename the column with the original name &quot;Age&quot; to &quot;age&quot;, and the third column to &quot;children&quot;. All other columns will keep the names that are specified in the file:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.csv&quot;, colnames=Dict(&quot;Age&quot;=&gt;&quot;age&quot;, 3=&gt;&quot;children&quot;))</code></pre><h4><a class="nav-anchor" id="Rows-to-Read-1" href="#Rows-to-Read-1">Rows to Read</a></h4><p><code>load</code> accepts two keyword arguments that allow you to specify whether all lines in the file should be read or not.</p><p>With the <code>skiplines_begin</code> argument you can tell <code>load</code> to ignore a certain number of lines at the beginning of the file. This is useful if you have a file like this:</p><pre><code class="language-none"># This file was generated on 1/1/2017
# By John
Name,Age,Children
&quot;John&quot;,34.,2
&quot;Sally&quot;,23.,1</code></pre><p>In this example the first two lines in the file contain some meta information that is not part of the table data itself. You can load such a file like this:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.csv&quot;, skiplines_begin=2) |&gt; DataFrame</code></pre><p>With that option, the first two lines will be ignored and the file is treated as if it started in line 3.</p><p>[TODO There should actually be an option to limit the number of rows that are read]</p><h4><a class="nav-anchor" id="Column-Types-1" href="#Column-Types-1">Column Types</a></h4><p>[TODO]</p><h4><a class="nav-anchor" id="Quote-and-Escape-Character-1" href="#Quote-and-Escape-Character-1">Quote and Escape Character</a></h4><p>If a CSV file has a column with string data, it should ideally surround the actual string in quotation marks <code>&quot;</code> or some other quote character. This is important because otherwise such a string column could not contain the character that is used as the delimiter character between columns. A typical example CSV file might look like this:</p><pre><code class="language-none">Name,Age
&quot;Smith, John&quot;,23.
&quot;Smith, Sally&quot;,35.</code></pre><p>Note that the values in the <code>Name</code> column here contain a comma <code>,</code> which is also the delimiter character between columns in this file. But because the whole string is surrounded by quotation marks <code>&quot;</code>, the CSV reader understands that the comma between the last and first name here is part of the <code>Name</code> column and does not separate the <code>Name</code> from the <code>Age</code> column.</p><p>Some CSV files use a different character as their quotation character. For example, a file might use single quotation marks <code>&#39;</code> like in this example:</p><pre><code class="language-none">Name,Age
&#39;Smith, John&#39;,23.
&#39;Smith, Sally&#39;,35.</code></pre><p>The keyword argument <code>quotechar</code> of the <code>load</code> function allows you to specify the quote character used in the file you want to load. The above file could be loaded like this:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.csv&quot;, quotechar=&#39;\&#39;&#39;) |&gt; DataFrame</code></pre><p>Note how we need to use the julia escape character <code>\</code> here to create a <code>Char</code> instance with content <code>&#39;</code>.</p><p>There is still a problem, though: what if you have a column that sometimes contains the character that is used as the quote character? For that case you can specify an escape character: whenever the escape character followed by the quote character appears in a column, the quote character is not interpreted as the end of the column, but as an appearance of that character in the column itself. An example file might look like this:</p><pre><code class="language-none">Text,Number
&quot;This text contains a \&quot; mark&quot;,23
&quot;This line doesn&#39;t&quot;,45</code></pre><p>The content of the first column in the first row here should be read as <code>This text contains a &quot; mark</code>. You can specify what character is used as the escape character with the <code>escapechar</code> keyword argument:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.csv&quot;, escapechar=&#39;\\&#39;)</code></pre><p>Note how we have to escape the <code>\</code> character itself in the julia string: <code>\</code> is the julia escape character, and to create a <code>Char</code> instance with content <code>\</code> we have to write <code>&#39;\\&#39;</code>.</p><h3><a class="nav-anchor" id="Saving-CSV-Files-1" href="#Saving-CSV-Files-1">Saving CSV Files</a></h3><p>To save a table as a CSV file, call the <code>save</code> function with a filename that has a <code>*.csv</code> extension. <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> will then use the <a href="https://github.com/davidanthoff/CSVFiles.jl">CSVFiles.jl</a> package to save the table. The following example shows how to save a table as a CSV file:</p><pre><code class="language-julia">using Dataverse

df = DataFrame(name=[&quot;John&quot;, &quot;Sally&quot;], age=[23.,25.])

df |&gt; save(&quot;mydata.csv&quot;)</code></pre><p>The <code>save</code> function accepts a number of arguments when saving a CSV file that control the precise format of the CSV file that is written.</p><h4><a class="nav-anchor" id="Delimter-character-2" href="#Delimter-character-2">Delimter character</a></h4><p>You can control which character should separate columns in the result file by passing the keyword argument <code>delim</code> to the <code>save</code> function. The following code uses a semicolon <code>;</code> as the column separator character:</p><pre><code class="language-julia">using Dataverse

df = DataFrame(name=[&quot;John&quot;, &quot;Sally&quot;], age=[23.,25.])

df |&gt; save(&quot;mydata.csv&quot;, delim=&#39;;&#39;)</code></pre><h4><a class="nav-anchor" id="Header-1" href="#Header-1">Header</a></h4><p>By default <code>save</code> writes the names of the columns as the first line in the CSV file. You can change that behavior by passing the <code>header=false</code> keyword argument:</p><pre><code class="language-julia">using Dataverse

df = DataFrame(name=[&quot;John&quot;, &quot;Sally&quot;], age=[23.,25.])

df |&gt; save(&quot;mydata.csv&quot;, header=false)</code></pre><p>This will write a CSV file that looks like this:</p><pre><code class="language-none">&quot;John&quot;,23.
&quot;Sally&quot;,25.</code></pre><h4><a class="nav-anchor" id="Quote-and-Escape-Character-2" href="#Quote-and-Escape-Character-2">Quote and Escape Character</a></h4><p>The <code>quotechar</code> and <code>escapechar</code> keyword arguments control how text columns get written to disc. By default <code>save</code> will surround any text by double quotation marks <code>&quot;</code>, and use a backslash <code>\</code> to escape any occurrence of the quote character in the actual text of a column. The following code instead uses plus <code>+</code> as the quote character and a forward slash <code>/</code> as the escape character:</p><pre><code class="language-julia">using Dataverse

df = DataFrame(name=[&quot;John + Jim&quot;, &quot;Sally&quot;], age=[23.,25.])

df |&gt; save(&quot;mydata.csv&quot;, quotechar=&#39;+&#39;, escapechar=&#39;/&#39;)</code></pre><p>This code will write the following CSV file:</p><pre><code class="language-none">+name+,+age+
+John /+ Jim+,23.
+Sally+,25.</code></pre><h2><a class="nav-anchor" id="Feather-Files-1" href="#Feather-Files-1">Feather Files</a></h2><p>[TODO add general description of Feather files]</p><h3><a class="nav-anchor" id="Loading-Feather-Files-1" href="#Loading-Feather-Files-1">Loading Feather Files</a></h3><p>If you pass a filename with the extension <code>*.feather</code> to the <code>load</code> function, <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> will use the <a href="https://github.com/davidanthoff/FeatherFiles.jl">FeatherFiles.jl</a> package to load that file. The following example demonstrates how you can load a Feather file:</p><pre><code class="language-julia">using Dataverse

# Load a local file
df = load(&quot;mydata.feather&quot;) |&gt; DataFrame</code></pre><p>There are no options you can specify when loading a Feather file.</p><h3><a class="nav-anchor" id="Saving-Feather-Files-1" href="#Saving-Feather-Files-1">Saving Feather Files</a></h3><p>You can save a table as a Feather file by calling the <code>save</code> function with a filename that has the <code>*.feather</code> extension. In that case <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> will use the <a href="https://github.com/davidanthoff/FeatherFiles.jl">FeatherFiles.jl</a> package to save that file. This example shows you how to save a table as a Feather file:</p><pre><code class="language-julia">using Dataverse

df = DataFrame(name=[&quot;John&quot;, &quot;Sally&quot;], age=[23.,25.])

df |&gt; save(&quot;mydata.feather&quot;)</code></pre><p>No other options can be specified when saving a Feather file.</p><h2><a class="nav-anchor" id="Excel-Files-1" href="#Excel-Files-1">Excel Files</a></h2><p>[TODO add general description of Excel files]</p><h3><a class="nav-anchor" id="Loading-Excel-Files-1" href="#Loading-Excel-Files-1">Loading Excel Files</a></h3><p>You can load both <code>*.xls</code> and <code>*.xlsx</code> files with <code>load</code>. If you pass a filename with one of those extensions to <code>load</code>, <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> will use the <a href="https://github.com/davidanthoff/ExcelFiles.jl">ExcelFiles.jl</a> package to load those files.</p><p>To load an Excel file, you always need to specify either a sheet name or range in addition to the filename itself.</p><p>The following example loads the sheet <code>Sheet1</code> from an Excel file:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.xlsx&quot;, &quot;Sheet1&quot;) |&gt; DataFrame</code></pre><p>When you pass a sheet name to <code>load</code> without any other option, it will automatically skip any initial empty rows or columns in the Excel file, and then read the remaining content on the sheet. You can also manually control what data should be read from the sheet by using a number of keyword arguments. The <code>skipstartrows</code> argument takes an <code>Int</code>, when specified the <code>load</code> function will ignore the first <code>skipstartrows</code> rows in the file. Note that in this case <code>load</code> will no longer attempt to automatically figure out on which row your data is starting in the sheet. The <code>skipstartcols</code> option works the same way, but for columns. The <code>nrows</code> and <code>ncols</code> keyword arguments allow you to specify how many rows and columns you want to read from the sheet. The following example uses all four options to skip the first two rows and first three columns, to then read a table with four rows and five columns:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.xlsx&quot;, &quot;Sheet1&quot;, skipstartrows=2, skipstartcols=3, nrows=4, ncols=5) |&gt; DataFrame</code></pre><p>Instead of passing a sheet name to <code>load</code>, you can also pass a full Excel range specification. Excel range specifications have the form <code>Sheetname!CellRef1:CellRef2</code>. <code>CellRef1</code> and <code>CellRef2</code> designate the top left and bottom right cell of the rectangle that you want to load. For example, the range specification <code>Sheet1!B2:D5</code> denotes the data on <code>Sheet1</code> that lies in the rectangle that has cell <code>B2</code> as the top left corner and <code>D5</code> as the bottom right corner. To load that data with julia you can use this code:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.xlsx&quot;, &quot;Sheet1!B2:D5&quot;) |&gt; DataFrame</code></pre><p>Without any other arguments, <code>load</code> will assume that the first row in this rectangle contains the columns names of a table. If that is not the case for your data, you can specify the keyword argument <code>header=false</code>, in which case <code>load</code> will treat the first row in the rectangle specified by the range as data. The columns will get automatically generated names. You can also pass custom column names with the <code>colnames</code> keyword argument, which accepts an array of <code>String</code>s. If you pass column names via the <code>colnames</code> argument with the option <code>header=true</code> (the default setting), <code>load</code> will ignore the first row in the range specified rectangle and instead use the names you passed in the <code>colnames</code> argument. The following code reads data from <code>Sheet1</code> in range <code>A2:C5</code>, treats the first row as data and assigns custom column names:</p><pre><code class="language-julia">using Dataverse

df = load(&quot;mydata.xlsx&quot;, &quot;Sheet1!B2:C5&quot;, header=false, colnames=[&quot;Name&quot;, &quot;Age&quot;, &quot;Children&quot;]) |&gt; DataFrame</code></pre><h2><a class="nav-anchor" id="Stata,-SPSS,-and-SAS-Files-1" href="#Stata,-SPSS,-and-SAS-Files-1">Stata, SPSS, and SAS Files</a></h2><p>[TODO add general description of stats files]</p><h3><a class="nav-anchor" id="Loading-Stata,-SPSS,-and-SAS-Files-1" href="#Loading-Stata,-SPSS,-and-SAS-Files-1">Loading Stata, SPSS, and SAS Files</a></h3><p>You can load files that were saved in one of the formats of these statistical software packages that have the extension <code>*.dta</code>, <code>*.por</code>, <code>*.save</code> or <code>*.sas7bdat</code>. If you call the <code>load</code> function with a filename with any of these extensions, <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> will use the <a href="https://github.com/davidanthoff/StatFiles.jl">StatFiles.jl</a> package to read those files. The following code example demonstrates how you can read a file in each of these formats:</p><pre><code class="language-julia">using Dataverse

df1 = load(&quot;mydata.dta&quot;) |&gt; DataFrame

df2 = load(&quot;mydata.por&quot;) |&gt; DataFrame

df3 = load(&quot;mydata.sav&quot;) |&gt; DataFrame

df4 = load(&quot;mydata.sas7bdat&quot;) |&gt; DataFrame</code></pre><p>There are no further options you can specify when loading one of these files.</p><h2><a class="nav-anchor" id="Parquet-Files-1" href="#Parquet-Files-1">Parquet Files</a></h2><p>[TODO add general description of Parquet files]</p><h3><a class="nav-anchor" id="Loading-Parquet-Files-1" href="#Loading-Parquet-Files-1">Loading Parquet Files</a></h3><p>If you pass a filename with the extension <code>*.parquet</code> to the <code>load</code> function, <a href="https://github.com/JuliaIO/FileIO.jl">FileIO.jl</a> will use the <a href="https://github.com/davidanthoff/ParquetFiles.jl">ParquetFiles.jl</a> package to load that file. The following example demonstrates how you can load a Feather file:</p><pre><code class="language-julia">using Dataverse

# Load a local file
df = load(&quot;mydata.parquet&quot;) |&gt; DataFrame</code></pre><p>There are no options you can specify when loading a Parquet file.</p><h2><a class="nav-anchor" id="Alternative-Packages-1" href="#Alternative-Packages-1">Alternative Packages</a></h2><p>This section described how you can use packages from the Dataverse to load and save data. While those are useful, they are not the only julia packages that you can use for tabular file IO, in fact there are many other excellent packages for those tasks. I encourage you to explore those packages and use them whenever they are a good fit for your work. Here is an (incomplete) list of other packages you might want to take a look at:</p><ul><li><p><a href="https://github.com/JuliaData/CSV.jl">CSV.jl</a>.</p></li><li><p><a href="https://github.com/cjprybol/uCSV.jl">uCSV.jl</a>.</p></li><li><p><a href="https://github.com/JuliaComputing/TextParse.jl">TextParse.jl</a> (*).</p></li><li><p><a href="https://github.com/strickek/ReadWriteDlm2.jl">ReadWriteDlm2.jl</a>.</p></li><li><p><a href="https://github.com/JuliaData/Feather.jl">Feather.jl</a> (*).</p></li><li><p><a href="https://github.com/WizardMac/ReadStat.jl">ReadStat.jl</a> (*).</p></li><li><p><a href="https://github.com/davidanthoff/ExcelReaders.jl">ExcelReaders.jl</a> (*).</p></li><li><p><a href="https://github.com/aviks/Taro.jl">Taro.jl</a>.</p></li><li><p><a href="https://github.com/CiaranOMara/Bedgraph.jl">Bedgraph.jl</a> (*).</p></li><li><p><a href="https://github.com/JuliaData/DBFTables.jl">DBFTables.jl</a>.</p></li><li><p><a href="https://github.com/JuliaStats/RData.jl">RData.jl</a>.</p></li></ul><p>Note that some of these packages actually power the Dataverse file IO packages, I have denoted those packages with (*).</p><footer><hr/><a class="previous" href="setup.html"><span class="direction">Previous</span><span class="title">Setup</span></a><a class="next" href="iterabletables.html"><span class="direction">Next</span><span class="title">Advanced - Iterable Tables</span></a></footer></article></body></html>
