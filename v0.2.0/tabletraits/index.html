<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced - TableTraits.jl · Julia for Data Science</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Julia for Data Science</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Julia for Data Science</a></li><li><a class="toctext" href="../setup/">Setup</a></li><li><a class="toctext" href="../fileio/">Tabular File IO</a></li><li class="current"><a class="toctext" href>Advanced - TableTraits.jl</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#The-iterable-tables-interface-1">The iterable tables interface</a></li><li><a class="toctext" href="#The-columns-copy-interface-[experimental]-1">The columns-copy interface [experimental]</a></li><li><a class="toctext" href="#The-columns-view-interface-1">The columns-view interface</a></li><li><a class="toctext" href="#The-TableTraitsUtils.jl-package-1">The TableTraitsUtils.jl package</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Advanced - TableTraits.jl</a></li></ul><a class="edit-page" href="https://github.com/davidanthoff/jl4ds/blob/master/docs/src/tabletraits.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Advanced - TableTraits.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Advanced-TableTraits.jl-1" href="#Advanced-TableTraits.jl-1">Advanced - TableTraits.jl</a></h1><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This chapter describes the TableTraits.jl interface as it existed on julia 0.6. There have been some small changes for julia 1.0 that are not yet reflected in this chapter.</p></div></div><p>This chapter describes the internals of various table interfaces that are defined in the <a href="https://github.com/queryverse/TableTraits.jl">TableTraits.jl</a> package. Most data science users do not need to read this chapter, it mostly targets developers that want to integrate their own packages with the ecosystem of packages described in this book.</p><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>The <a href="https://github.com/queryverse/TableTraits.jl">TableTraits.jl</a> defines three interfaces that a table can implement: the iterable tables interface, the columns-copy interface and the columns-view interface. A function that accepts a table as an argument can then use these interfaces to access the data in the table. By accessing the data in the table via one of these three interfaces, the function can interact with many different types of tables, without taking a dependency on any specific table implementation.</p><p>While the three table interfaces are entirely independent from each other, one of the three is more equal than the others: any table that wants to participate in the Queryverse ecosystem <em>must</em> implement the iterable tables interface, and every function that accepts a table as an argument <em>must</em> be able to access the data from that table via the iterable tables interface. The iterable tables interface is thus the most fundamental and basic of the three interfaces that any implementation must support. The two other interfaces (columns-copy and columns-view) are more specialized, but can provide much better performance in certain situations. Tables and table consumers <em>may</em> support those interfaces in addition to the iterable tables interface.</p><p>The <a href="https://github.com/queryverse/TableTraitsUtils.jl">TableTraitsUtils.jl</a> package provides a number of helper functions that make it easier to implement and consume the interfaces described in this package. Most packages that want to integrate with the ecosystem described in this chapter should first check whether any of the helper functions in that package can be used to implement these interfaces, before attempting to follow the guidelines in this chapter to implement these interfaces manually.</p><h2><a class="nav-anchor" id="The-iterable-tables-interface-1" href="#The-iterable-tables-interface-1">The iterable tables interface</a></h2><h3><a class="nav-anchor" id="Specification-1" href="#Specification-1">Specification</a></h3><p>The iterable table interface has two core parts:</p><ol><li>A simple way for a type to signal that it is an iterable table. It also provides a way for consumers of an iterable table to check whether a particular value is an iterable table and a convention on how to start the iteration of the table.</li><li>A number of conventions how tabular data should be iterated.</li></ol><p>In addition, <a href="https://github.com/queryverse/TableTraits.jl">TableTraits.jl</a> provides a number of small helper functions that make it easier to implement an iterable table consumer.</p><h4><a class="nav-anchor" id="Signaling-and-detection-of-iterable-tables-1" href="#Signaling-and-detection-of-iterable-tables-1">Signaling and detection of iterable tables</a></h4><p>In general a type is an iterable table if it can be iterated and if the element type that is returned during iteration is a <code>NamedTuple</code>.</p><p>In a slight twist of the standard julia iteration interface, iterable tables introduces one extra step into this simple story: consumers should never iterate a data source directly by calling the <code>start</code> function on it, instead they should always call <code>IteratorInterfaceExtensions.getiterator</code> on the data source, and then use the standard julia iterator protocol on the value return by <code>IteratorInterfaceExtensions.getiterator</code>. This function is defined in the <a href="https://github.com/queryverse/IteratorInterfaceExtensions.jl">IteratorInterfaceExtensions.jl</a> package.</p><p>This indirection enables us to implement type stable iterator functions <code>start</code>, <code>next</code> and <code>done</code> for data sources that don&#39;t incorporate enough information in their type for type stable versions of these three functions (e.g. <code>DataFrame</code>s). <a href="https://github.com/queryverse/IteratorInterfaceExtensions.jl">IteratorInterfaceExtensions.jl</a> provides a default implementation of <code>IteratorInterfaceExtensions.getiterator</code> that just returns that data source itself. For data sources that have enough type information to implement type stable versions of the iteration functions, this default implementation of <code>IteratorInterfaceExtensions.getiterator</code> works well. For other types, like <code>DataFrame</code>, package authors can provide their own <code>IteratorInterfaceExtensions.getiterator</code> implementation that returns a value of some new type that has enough information encoded in its type parameters so that one can implement type stable versions of <code>start</code>, <code>next</code> and <code>done</code>.</p><p>The function <code>IteratorInterfaceExtensions.isiterable</code> enables a consumer to check whether any arbitrary value is iterable, in the sense that <code>IteratorInterfaceExtensions.getiterator</code> will return something that can be iterated. The default <code>IteratorInterfaceExtensions.isiterable(x::Any)</code> implementation checks whether a suitable <code>start</code> method for the type of <code>x</code> exists. Types that use the indirection described in the previous paragraph might not implement a <code>start</code> method, though. Instead they will return a type for which <code>start</code> is implemented from the <code>IteratorInterfaceExtensions.getiterator</code> function. Such types should manually add a method to <code>IteratorInterfaceExtensions.isiterable</code> that returns <code>true</code> for values of their type, so that consumers can detect that a call to <code>IteratorInterfaceExtensions.getiterator</code> is going to be successful.</p><p>The final function in the detection and signaling interface of iterable tables is <code>TableTraits.isiterabletable(x)</code>. This function is defined in the <a href="https://github.com/queryverse/TableTraits.jl">TableTraits.jl</a> package. The fallback implementation for this method will check whether <code>IteratorInterfaceExtensions.isiterable(x)</code> returns <code>true</code>, and whether <code>eltype(x)</code> returns a <code>NamedTuple</code>. For types that don&#39;t provide their own <code>IteratorInterfaceExtensions.getiterator</code> method this will signal the correct behavior to consumers. For types that use the indirection method described above by providing their own <code>IteratorInterfaceExtensions.getiterator</code> method, package authors should provide their own <code>TableTraits.isiterabletable</code> method that returns <code>true</code> if that data source will iterate values of type <code>NamedTuples</code> from the value returned by <code>IteratorInterfaceExtensions.getiterator</code>.</p><h4><a class="nav-anchor" id="Iteration-conventions-1" href="#Iteration-conventions-1">Iteration conventions</a></h4><p>Any iterable table should return elements of type <code>NamedTuple</code>. Each column of the source table should be encoded as a field in the named tuple, and the type of that field in the named tuple should reflect the data type of the column in the table. If a column can hold missing values, the type of the corresponding field in the <code>NamedTuple</code> should be a <code>DataValue{T}</code> where <code>T</code> is the data type of the column. The <code>NamedTuple</code> type is defined in the <a href="https://github.com/blackrock/NamedTuples.jl">NamedTuples.jl</a> package, and the <code>DataValue</code> is defined in the <a href="https://github.com/queryverse/DataValues.jl">DataValues.jl</a> package.</p><h3><a class="nav-anchor" id="Integration-Guide-1" href="#Integration-Guide-1">Integration Guide</a></h3><p>This section describes how package authors can integrate their own packages with the iterable tables ecosystem. Specifically, it explains how one can turn a type into an iterable table and how one can write code that consumes iterable tables.</p><p>The code that integrates a package with the iterable tables ecosystem should live in the repository of that package. For example, if <code>Foo.jl</code> wants to be integrated with the iterable tables ecosystem, one should add the necessary code to the <code>Foo.jl</code> repository.</p><h4><a class="nav-anchor" id="Consuming-iterable-tables-1" href="#Consuming-iterable-tables-1">Consuming iterable tables</a></h4><p>One cannot dispatch on an iterable table because iterable tables don&#39;t have a common super type. Instead one has to add a method that takes a value of any type as an argument to consume an iterable table. For conversions between types it is recommended that one adds a constructor that takes one argument without any type restriction that can convert an iterable table into the target type. For example, if one has added a new table type called <code>MyTable</code>, one would add a constructor with this method signature for this type: <code>function MyTable(iterable_table)</code>. For other situations, for example a plotting function, one also would add a method without any type restriction, for example <code>plot(iterable_table)</code>.</p><p>The first step inside any function that consumes iterable tables is to check whether the argument that was passed is actually an iterable table or not. This can easily be done with the <code>TableTraits.isiterabletable</code> function. For example, the constructor for a new table type might start like this:</p><pre><code class="language-julia">function MyTable(source)
    TableTraits.isiterabletable(source) || error(&quot;Argument is not an iterable table.&quot;)

    # Code that converts things follows
end</code></pre><p>Once it has been established that the argument is actually an iterable table there are multiple ways to proceed. The following two sections describe three options, which one is appropriate for a given situation depends on a variety of factors.</p><h5><a class="nav-anchor" id="Reusing-an-existing-consumer-of-iterable-tables-1" href="#Reusing-an-existing-consumer-of-iterable-tables-1">Reusing an existing consumer of iterable tables</a></h5><p>This option is by far the simplest way to add support for consuming an iterable table. Essentially the strategy is to reuse the conversion implementation of some other type. For example, one can simply convert the iterable table into a <code>DataFrame</code> right after one has checked that the argument of the function is actually an iterable table. Once the iterable table is converted to a <code>DataFrame</code>, one can use the standard API of <code>DataFrame</code>s to proceed. This strategy is especially simple for packages that already support interaction with <code>DataFrames</code> (or any of the other table types that support the iterable tables interface). The code for the <span>$MyTable$</span> constructor might look like this:</p><pre><code class="language-julia">function MyTable(source)
    TableTraits.isiterabletable(source) || error(&quot;Argument is not an iterable table.&quot;)

    df = DataFrame(source)
    return MyTable(df)
end</code></pre><p>This assumes that <code>MyTable</code> has another constructor that accepts a <code>DataFrame</code>.</p><p>While this strategy to consume iterable tables is simple to implement, it leads to a tighter couping than needed in many situations. In particular, a package that follows this strategy will still need a dependency on an existing table type, which is often not ideal. I therefore recommend this strategy only as a first quick-and-dirty way to get compatible with the iterable table ecosystem. The two two options described in the next sections are generally more robust ways to achieve the iterable table integration.</p><h5><a class="nav-anchor" id="Coding-a-complete-conversion-1" href="#Coding-a-complete-conversion-1">Coding a complete conversion</a></h5><p>Coding a custom conversion is more work than reusing an existing consumer of iterable tables, but it provides more flexibility.</p><p>In general, a custom conversion function also needs to start with a call to <code>TableTraits.isiterabletable</code> to check whether one actually has an iterable table. The second step in any custom conversion function is to call the <code>IteratorInterfaceExtensions.getiterator</code> function on the iterable table. This will return an instance of a type that implements the standard julia iterator interface, i.e. one can call <code>start</code>, <code>next</code> and <code>done</code> on the instance that is returned by <code>IteratorInterfaceExtensions.getiterator</code>. For some iterable tables <code>IteratorInterfaceExtensions.getiterator</code> will just return the argument that one has passed to it, but for other iterable tables it will return an instance of a different type.</p><p><code>IteratorInterfaceExtensions.getiterator</code> is generally not a type stable function. Given that this function is generally only called once per conversion this hopefully is not a huge performance issue. The functions that really need to be type-stable are <code>start</code>, <code>next</code> and <code>done</code> because they will be called for every row of the table that is to be converted. In general, these three functions will be type stable for the type of the return value of <code>IteratorInterfaceExtensions.getiterator</code>. But given that <code>IteratorInterfaceExtensions.getiterator</code> is not type stable, one needs to use a function barrier to make sure the three iteration functions are called from a type stable function.</p><p>The next step in a custom conversion function is typically to find out what columns the iterable table has. The helper functions <code>TableTraits.column_types</code> and <code>TableTraits.column_names</code> provide this functionality (note that these are not part of the official iterable tables interface, they are simply helper functions that make it easier to find this information). Both functions need to be called with the return value of `<code>IteratorInterfaceExtensions.getiterator</code> as the argument. <code>TableTraits.column_types</code> returns a vector of <code>Type</code>s that are the element types of the columns of the iterable table. <code>TableTraits.column_names</code> returns a vector of <code>Symbol</code>s with the names of the columns.</p><p>Custom conversion functions can at this point optionally check whether the iterable table implements the <code>length</code> function by checking whether <code>Base.iteratorsize(typeof(iter))==Base.HasLength()</code> (this is part of the standard iteration protocol). It is important to note that every consumer of iterable tables needs to handle the case where no length information is available, but can provide an additional, typically faster implementation if length information is provided by the source. A typical pattern might be that a consumer can pre-allocate the arrays that should hold the data from the iterable tables with the right size if length information is available from the source.</p><p>With all this information, a consumer now typically would allocate the data structures that should hold the converted data. This will almost always be very consumer specific. Once these data structures have been allocated, one can actually implement the loop that iterates over the source rows. To get good performance it is recommended that this loop is implemented in a new function (behind a function barrier), and that the function with the loop is type-stable. Often this will require the use of a generated function that generates code for each column of the source. This can avoid a loop over the columns while one is iterating over the rows. It is often key to avoid a loop over columns inside the loop over the rows, given that columns can have different types, which almost inevitably would lead to a type instability. </p><p>A good example of a custom consumer of an iterable table is the code in the <code>DataTable</code> integration.</p><h4><a class="nav-anchor" id="Creating-an-iterable-table-source-1" href="#Creating-an-iterable-table-source-1">Creating an iterable table source</a></h4><p>There are generally two strategies for turning some custom type into an iterable table. The first strategy works if one can implement a type-stable version of <code>start</code>, <code>next</code> and <code>done</code> that iterates elements of type <code>NamedTuple</code> directly for the source type. If that is not feasible, the strategy is to create a new iterator type. The following two sections describe both approaches.</p><h5><a class="nav-anchor" id="Directly-implementing-the-julia-base-iteration-trait-1" href="#Directly-implementing-the-julia-base-iteration-trait-1">Directly implementing the julia base iteration trait</a></h5><p>This strategy only works if the type that one wants to expose as an iterable table has enough information about the structure of the table that one can implement a type stable version of <code>start</code>, <code>next</code> and <code>done</code>. Typically that requires that one can deduce the names and types of the columns of the table purely from the type (and type parameters). For some types that works, but for other types (like <code>DataFrame</code>) this strategy won&#39;t work.</p><p>If the type one wants to expose as an iterable table allows this strategy, the implementation is fairly straightforward: one simple needs to implement the standard julia base iterator interface, and during iteration one should return <code>NamedTuple</code>s for each element. The fields in the <code>NamedTuple</code> correspond to the columns of the table, i.e. the names of the fields are the column names, and the types of the field are the column types. If the source supports some notion of missing values, it should return <code>NamedTuples</code> that have fields of type <code>DataValue{T}</code>, where <code>T</code> is the data type of the column.</p><p>It is important to not only implement <code>start</code>, <code>next</code> and <code>end</code> from the julia iteration protocol. Iterable tables also always require that <code>eltype</code> is implemented. Finally, one should either implement <code>length</code>, if the source supports returning the number of rows without expensive computations, or one should add a method <code>iteratorsize</code> that returns <code>SizeUnknown()</code> for the custom type.</p><p>The implementation of a type stable <code>next</code> method typically requires the use of generated functions.</p><h5><a class="nav-anchor" id="Creating-a-custom-iteration-type-1" href="#Creating-a-custom-iteration-type-1">Creating a custom iteration type</a></h5><p>For types that don&#39;t have enough information encoded in their type to implement a type stable version of the julia iteration interface, the best strategy is to create a custom iteration type that implements the julia iteration interface and has enough type information.</p><p>For example, for the <code>MyTable</code> type one might create a new iterator type called <code>MyTableIterator{T}</code> that holds the type of the <code>NamedTuple</code> that this iterator will return in <code>T</code>.</p><p>To expose this new iterator type to consumers, one needs to add a method to the <code>IteratorInterfaceExtensions.getiterator</code> function. This function takes an instance of the type one wants to expose as an iterable table, and returns a new type that should actually be used for the iteration itself. For example, <code>function IteratorInterfaceExtensions.getiterator(table::MyTable)</code> would return an instance of <code>MyTableIterator{T}</code>.</p><p>In addition to adding a method to <code>IteratorInterfaceExtensions.getiterator</code>, one must also add methods to the <code>IteratorInterfaceExtensions.isiterable</code> and <code>TableTraits.isiterabletable</code> functions for the type one wants to turn into an iterable table, in both cases those methods should return <code>true</code>.</p><p>The final step is to implement the full julia iteration interface for the custom iterator type that one returned from <code>IteratorInterfaceExtensions.getiterator</code>. All the same requirements that were discussed in the previous section apply here as well.</p><p>An example of this strategy is the <code>DataTable</code> integration.</p><h2><a class="nav-anchor" id="The-columns-copy-interface-[experimental]-1" href="#The-columns-copy-interface-[experimental]-1">The columns-copy interface [experimental]</a></h2><p>Note that this interface is still experimental and might change in the future.</p><h3><a class="nav-anchor" id="Specification-2" href="#Specification-2">Specification</a></h3><p>The columns-copy interface consists of only two functions: <code>TableTraits.supports_get_columns_copy</code> (to check whether a table supports this interface) and <code>TableTraits.get_columns_copy</code> (to get a copy of all the columns in the table).</p><p>This interface allows a consumer of a table to obtain a copy of the data in a table. The copy will consist of one vector for each column of the source table. The key feature of this interface is that the consumer of this interface will &quot;own&quot; the vectors that are obtained via this interface. The consumer can modify, delete or do anything else with the vectors returned from this interface. This implies that a source that returns columns via this interface should not hold onto the actual vectors that it returns via this interface.</p><p>The <code>TableTraits.supports_get_columns_copy</code> function accepts one argument that has to be a table. It will return <code>true</code> or <code>false</code>, depending on whether the table supports the columns-copy interface or not.</p><p>The <code>TableTraits.get_columns_copy</code> function also accepts one argument that is a table. It returns a <code>NamedTuple</code> with one field for each column in the source table. Each field should hold a vector with the actual values for that column.</p><p>If the source table supports a notion of missing data in a column, it should return a <code>DataValueVector</code> from the <a href="https://github.com/queryverse/DataValues.jl">DataValues.jl</a> package for such columns.</p><h2><a class="nav-anchor" id="The-columns-view-interface-1" href="#The-columns-view-interface-1">The columns-view interface</a></h2><h3><a class="nav-anchor" id="Specification-3" href="#Specification-3">Specification</a></h3><p>The columns-view interface consists of only two functions: <code>TableTraits.supports_get_columns_view</code> (to check whether a table supports this interface) and <code>TableTraits.get_columns_view</code> (to get a view into the source table).</p><p>This interface allows a consumer of a table to get access to the columns in a table via a standardized interface. In particular, a consumer can obtain a <code>NamedTuple</code> of columns from a source table that give access to the data in the source table. The key feature of this interface is that the consumer is only allowed to read data from the arrays returned by this interface. The consumer must not attempt to modify the content of the source table via the arrays that were returned from this interface. A source should in general not make copies of the data if it implements this interface. In essence this interface gives a read-only view into a table that a consumer can use to access any cell in a table.</p><p>The <code>TableTraits.supports_get_columns_view</code> function accepts one argument that has to be a table. It will return <code>true</code> or <code>false</code>, depending on whether the table supports the columns-view interface or not.</p><p>The <code>TableTraits.get_columns_view</code> function also accepts one argument that is a table. It returns a <code>NamedTuple</code> with one field for each column in the source table. Each field should hold a vector with the actual values for that column.</p><p>If the source table supports a notion of missing data in a column, the <code>eltype</code> of the vector for that column must be of type <code>DataValue</code>.</p><h2><a class="nav-anchor" id="The-TableTraitsUtils.jl-package-1" href="#The-TableTraitsUtils.jl-package-1">The TableTraitsUtils.jl package</a></h2><p>[TODO]</p><footer><hr/><a class="previous" href="../fileio/"><span class="direction">Previous</span><span class="title">Tabular File IO</span></a></footer></article></body></html>
